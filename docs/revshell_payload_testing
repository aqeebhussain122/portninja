Layout of Program: 
• An attacker uses command execution from the target box to execute the client payload. 
• The client payload connect to a malicious server on port x.
• The attacking server listens on port x for the clients connection, once recieved the connection is bound and occupies port x. 
• The attacking server establishes and maintains that connection by creating a socket, binding to a port and listening for a connection to come through. 
• Commands are transmit from server to client over the wire by encoded bytes. Once recieved on client-side, they are decoded to data-type string. 
• The client payload listens for the server commands and executes them in string format using a while loop with hardcoded commands and their functionality. It does so using its own subprocess.



TLDR: Sever & Client maintain a connection, server sends requests, client executes requests with hardcoded functionality within its local payload.
=================================================================================================================================================================================
What else do we need to do:

- full pty capabilites 
- shell encryption 
- testing
=================================================================================================================================================================================

Full PTY capabilites:
(copp)
commands, usage functionality, error handling, (google everything needed for a good pty shell), (figure out the inner workings of a fully functional PTY shell)
- Our own Subprocess for executing commands
- full pty capabilites 
	client side:
	commands, usage functionality, error handling, (google everything needed for a good pty shell), (figure out the inner workings of a fully functional PTY shell)
	- Our own Subprocess for executing commands

SubProcess Section:
-------------------
their subprocess how it works:
opens cmd
shows input and output of bytes
read and write
some command error handling
(basically how the cmd works. pre-built bash shell everyone uses.)



So to create our own sub process we need to build our own package of commands.
lets use a template as we'll be building so many commands:
if command = ...
	os.chdir(command[...])
	execute
	print results



each time an command is input the program will scan over every if statement. This may be a better way to do it but idk:
array_commands[cd, ls, ..., ...,]
if argv1 = array_commands, value = True
else exit()



understand the inner workings of a shell:
...

=================================================================================================================================================================================
- shell encryption 
(future ting, google a bit tho)







=================================================================================================================================================================================
Playzone:


Aqeeb notes for the 2hr:
we need to scope our path ahead properly in terms of what’s actually needed.
	<done>
take a step back and figure it out first
	<done>
We talk about it, draw it, pseudocode it.
	<need to pseudocode>
Can we understand what it is we’re trying to do?
	<we are trying to create a beautiful custom shell which successfuly speaks from client-server) 
We really need to understand the inner workings of an actual shell and how to incorporate a fully functional PTY shell.
	<working on that>

Shell development:
	maybe use bash shell and personaly improve its functionality. 
	<possibly but naw.>
	we have errors in our shell which need to be fixed to make it fully pty compatible 
	<Do some testing>




=================================================================================================================================================================================
=================================================================================================================================================================================
Old:
Create a reliable network program to send data between a network sender and listener (reverse shell)

Create a network Socket 
  •
  •
  •
Create our own Shell (C programming job and will serve as part of the payload being sent over the wire)
  •
  •
  •
Create a client Payload
  •
  •
  •
Create a python server to which the target connects to via command injection (Command & Control) 
  • create() - Create the socket
  • bind() - Bind the socket to a port 
  • accept() - Accept a connection which comes in and create a blocking state
  • send_commands() - Send commands to the recieved payload with encoding
  • receive_commands() - Print and receive the appropriate decoded output for us to interact with the target. 
  
Client-Sever:
  Description:
    Attacker: Netcat connection (Socket open on port) <- That socket then catches a known payload such as Python, perl or whatever to open bin/sh or bin/bash
    Our case: We create a server in which we handle sockets, create, bind, accept sockets then we send/receive commands back & forth to our target via reverse shell mechanism.
    
    
  • Currently building both the client functionality & the python sever - (Reference & base code) -  https://www.thepythoncode.com/code/create-reverse-shell-python
  • Most of the PoC done, once error handling is complete.
  • Subprocess work to do.
============================================================================================================================
Older:
  
Create a network socket.
---------
Function to print errors from processers
'buffer' = amount of characters read from the socket
---------
We create the server and client address using a struct known as sockaddr_in
---------
'htons' - thin layer between the code and how its interpreted in memory (network byte order)
  how the binary and the machine interprets the port number.
  converts a port number in host byte order to a port number in network byte order.
---------
memset is libary to initilize memory from a start point to an endpoint for the data to populated
bzero adds 0's into sections of memory
  First zero out an entire memory space from point a to b. Then we initialize our own variables into it.
---------
Next stage:
Make our own reliable network program to send data between a network sender and listener. reverse shell
---------
Extra:
"A socket is an abstraction of a communication endpoint"
file descriptors as we are essential accessing a file.
============================================================================================================================
