Other:
  All the error handling happens in the scan_http function
  HTTP status code is collected using GET not HEAD
-----------------------------
main()
  List extraction is done in main()
  Most outputs are done in main()

-----------------------------
sys.exits:
  Current sys.exits = 2
    system.exit if no ports are open.
    if cgi_bin is = 404, sys.exit
    
  Future sys.exits:
    if no cgi_bin files in cgi_bin dir, sys.exit
 -----------------------------
DAY 2:

Goal:
try 1:
Get netcat (ip and port) to go straight to bin/py 
our side: open bind shell so the target can connect to us
try 2:
install python reverse shell as a binary. (no need for python on the target box)


Process:
try 1:
/bin/py waits for connections
attacker sends connection to /bin/py 
try 2:
execute file on their machine
listen on our machine.


Extra:
bin/py is alias for our payload
-------------------------------------
Step 1:
1st craft a HEAD request to the target cgi-bin page,
then modify the user agent with a malicious function of shellshock to get command execution for payload.
inject payload via our command execution
append host with target HTTP host to finish the HTTP head request
then, get the output and give it to a network socket
upon which the target resides (ip and port)

-------------------------------------
Step 2:
payload comes back to us (as its a reverse shell)
	must have full pty capabilites.
	
	


NEW STTTTTTTTTTTTTTTTTTTTEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEPS:
step1:
target has shellshock vuln so we have command execution. attacker has payload hosted on python http server. wget payload from target via shellshock.--
step2:
download payload onto /tmp or /dev/shm
then netcat call on the target machine to envoke our payload and send it back to the attacker box.
